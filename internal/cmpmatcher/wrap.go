package cmpmatcher

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

func cmpMatcherDecls(fset *token.FileSet, suffix string) []ast.Decl {
	src := fmt.Sprintf(`
package mock

type cmpMatcher_%s struct {
	got  any
	want any
}

func (c *cmpMatcher_%s) Matches(got interface{}) bool {
	return cmp.Equal(got, c.want)
}

func (c *cmpMatcher_%s) Got(got any) string {
	c.got = got
	return "\033[2K\033[A"
}

func (c *cmpMatcher_%s) String() string {
	return cmp.Diff(c.want, c.got)
}

func CmpMatcher_%s(want any) gomock.Matcher {
	return &cmpMatcher_%s{want: want}
}

func CmpMatchers_%s(wants []any) []any {
	matchers := make([]any, 0, len(wants))
	for _, want := range wants {
		matchers = append(matchers, &cmpMatcher_%s{want: want})
	}
	return matchers
}
`, suffix, suffix, suffix, suffix, suffix, suffix, suffix, suffix)
	file, err := parser.ParseFile(fset, "", src, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	return file.Decls
}

func wrapCmpMatcher(fileName string) error {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return err
	}
	if len(file.Comments) == 0 || len(file.Comments[0].List) == 0 {
		return nil
	}
	if file.Comments[0].List[0].Text != "// Code generated by MockGen. DO NOT EDIT." {
		return nil
	}

	log.Println("wrapCmpMatcher: ", fileName)
	// for _, v := range file.Decls {
	// 	ast.Print(fset, v)
	// 	fmt.Println()
	// }

	suffix, err := hashFile(fileName)
	if err != nil {
		return err
	}

	importSpec := &ast.ImportSpec{
		Path: &ast.BasicLit{
			Kind:  token.STRING,
			Value: `"github.com/google/go-cmp/cmp"`,
		},
	}

	importDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: []ast.Spec{importSpec},
	}

	var importAdded, cmpFuncAdded bool
	ast.Inspect(file, func(n ast.Node) bool {
		// add import
		genDecl, ok := n.(*ast.GenDecl)
		if ok && genDecl.Tok == token.IMPORT {
			genDecl.Specs = append(genDecl.Specs, importSpec)
			importAdded = true
			return true
		}

		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == "_cmpMatcher" {
				cmpFuncAdded = true
				return true
			}
		}

		call, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}

		funcIdent, ok := call.Fun.(*ast.Ident)
		if !ok {
			if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
				funcIdent = sel.Sel
			}
		}

		if funcIdent != nil && funcIdent.Name == "RecordCallWithMethodType" {
			funcName := "CmpMatcher_" + suffix
			if call.Ellipsis != token.NoPos {
				funcName = "CmpMatchers_" + suffix
			}
			if len(call.Args) < 3 {
				return true
			}
			for i := range call.Args[3:] {
				before := call.Args[i+3]
				if c, ok := before.(*ast.CallExpr); ok {
					if ident, ok := c.Fun.(*ast.Ident); ok && strings.HasPrefix(ident.Name, "CmpMatcher_") {
						continue
					}
				}
				call.Args[i+3] = &ast.CallExpr{
					Fun: ast.NewIdent(funcName),
					Args: []ast.Expr{
						before,
					},
				}
			}
		}

		return true
	})

	if !importAdded {
		file.Decls = append([]ast.Decl{importDecl}, file.Decls...)
	}

	if !cmpFuncAdded {
		file.Decls = append(file.Decls, cmpMatcherDecls(fset, suffix)...)
	}

	f, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	if err := format.Node(f, fset, file); err != nil {
		return err
	}
	return nil
}
